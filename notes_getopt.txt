Each call returns information about the next unprocessed option.
If an option was found, the option character is returned as the function result.
If the end of the option list was reached, getopt() returns –1.
If an option has an argument, getopt() sets the global variable optarg to point to that argument.
If an option doesn’t have an argument, then the glibc getopt() implementation (like most other implementations) sets optarg to NULL.
On each call to getopt(), the global variable optind is updated to contain the index of the next unprocessed element of argv. (When multiple options are grouped in a single word, getopt() does some internal bookkeeping to keep track of which part of the word is next to be processed.) The optind variable is automatically set to 1 before the first call to getopt().

There are two circumstances where we may make use of optind:
- If getopt() returns –1, indicating that no more options are present and optind is less than argc, then argv[optind] is the location of the next nonoption word from the command line.
- If we are processing multiple command-line vectors or rescanning the same command line, then we must explicitly reset optind to 1.

- si on rencontre un "--" optind renvoie l'index de l'argument suivant.




ALGORITHME

important : ocmment s'assurer qu'on est bien en train de scanner la meme fonction ? comment remettre a zero les parametres statiques si on reutilise la fonction ?
=> avant de renvoyer -1 on reinitialise tout. La fonction n'est pas censée être utilisée en dehors d'une boucle qui termine par -1 ou erreur.

INITIALISATION
optind est à 1
opterr est à 1 => sur ? comment le passer a 0 depuis l'exterieur ?
optopt est à zero => et redevient zero apres la fin de la boucle
//une statique lastind garde en memoire l'index de l'argument dans lequel la derniere option a ete trouvee, initialisee à 1.

FIN STANDARD
si argv[optind] == NULL alors retourne -1;
si argv[optind][0] n'est pas un - alors -1;
si argv[optind] == - ou --, retourne -1;

CAS D'ERREUR
si l'option évaluée ne fait pas partie de la liste, retourne '?' et la globale optopt contient l'option qui pose probleme.
imprime un message d'erreur sur la sortie d'erreur si la globale opterr est à 1, et pas à 0.
si le premier caractere de optsting est un : alors pas de message d'erreur mais s'il manque un argument alors le retour est un ':';

CAS GENERAL
On verifie si optreset, auquel cas on remet optopt a zero ??? => je ne comprends pas exactement ce que fait optreset
On vérifie les cas de fin standard.
Si ce n'est pas le cas:
si optopt est à 0, c'est qu'on cherche pour la premiere fois dans optind. optopt devient donc argv[optind][1] (en 0 il y a '-').
sinon, on cherche optopt dans argv[optind]. optopt prend alors nécessairement le caractère suivant (on part du principe que le boulot de optind a bien ete fait par ailleurs).
On evalue alors le caractere optopt.
S'il n'appartient pas à la liste, cas d'erreur.
S'il attend un argument:
- si l'argument n'est pas présent, cas d'erreur.
- s'il est présent, alors 
Sinon, OK.
S'il n'attendait pas d'argument:
- si le caractère suivant est NULL, on incremente optind et on passe le caractere matché dans optopt.
- sinon, on passe juste dans optopt.
S'il attendait un argument, alors :
- si le prochain caractere est NULL, alors on passe le pointeur de argv[optind + 1] à la globale optarg puis on incremente optind de 2 et on passe la valeur ascii du caractere trouvé dans optopt.
- sinon, on passe le pointeur argv[optind] + offset + 1, puis on incremente optind et on passe la valeur ascii du caractere trouvé dans optopt.

On renvoie l'argument trouvé (il faut le garder dans une variable au prealable).
